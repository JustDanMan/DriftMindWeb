@page "/chat"
@using DriftMindWeb.Services
@using Microsoft.AspNetCore.Components.Forms
@inject IDriftMindApiService ApiService
@inject IMarkdownService MarkdownService
@inject IJSRuntime JSRuntime
@inject IConfiguration Configuration
@rendermode InteractiveServer

<PageTitle>DriftMind Chat</PageTitle>

<div class="chat-container">
    <div class="chat-header">
        <h2>
            <i class="bi bi-chat-dots"></i>
            DriftMind AI Assistant
        </h2>
        <p class="text-muted">Laden Sie Dokumente hoch oder stellen Sie Fragen zu Ihren Inhalten</p>
    </div>

    <!-- Upload Section -->
    <div class="upload-section @(showUpload ? "expanded" : "collapsed")">
        <div class="upload-header">
            <div class="upload-buttons">
                <button class="btn btn-outline-primary mb-3" @onclick="ToggleUpload">
                    <i class="bi bi-cloud-upload"></i>
                    @(showUpload ? "Upload verbergen" : "Dokument hochladen")
                </button>
                @if (ChatHistoryEnabled && HasChatHistory())
                {
                    <button class="btn btn-outline-primary mb-3" @onclick="ClearChatHistory" title="Chat-Verlauf löschen">
                        <i class="bi bi-trash3"></i>
                        @GetNewChatButtonText()
                    </button>
                }
            </div>
        </div>
        
        @if (showUpload)
        {
            <div class="upload-form">
                <div class="upload-tabs">
                    <button type="button" class="btn @(uploadMode == "text" ? "btn-primary" : "btn-outline-primary") me-2" 
                            @onclick="@(() => SetUploadMode("text"))">
                        <i class="bi bi-textarea-t"></i> Text eingeben
                    </button>
                    <button type="button" class="btn @(uploadMode == "file" ? "btn-primary" : "btn-outline-primary")" 
                            @onclick="@(() => SetUploadMode("file"))">
                        <i class="bi bi-file-earmark-arrow-up"></i> Datei hochladen
                    </button>
                </div>

                @if (uploadMode == "text")
                {
                    <div class="text-upload-section">
                        <div class="mb-3">
                            <label for="documentText" class="form-label">Text/Dokument</label>
                            <textarea @bind="documentText" class="form-control" id="documentText" rows="6" 
                                      placeholder="Fügen Sie hier Ihren Text ein..."></textarea>
                        </div>
                    </div>
                }
                else
                {
                    <div class="file-upload-section">
                        <div class="mb-3">
                            <label for="fileInput" class="form-label">Datei auswählen</label>
                            <InputFile OnChange="HandleFileSelection" class="form-control" id="fileInput" 
                                      accept=".txt,.md,.pdf,.docx" />
                            <div class="form-text">
                                Unterstützte Formate: .txt, .md, .pdf, .docx (max. @MaxUploadSizeMB MB)
                            </div>
                            @if (selectedFile != null)
                            {
                                <div class="selected-file-info mt-2">
                                    <div class="alert alert-info">
                                        <i class="bi bi-file-earmark"></i>
                                        <strong>@selectedFile.Name</strong> 
                                        <span class="text-muted">(@FormatFileSize(selectedFile.Size))</span>
                                    </div>
                                </div>
                            }
                        </div>
                    </div>
                }
                
                <!-- Advanced Options Toggle -->
                <div class="mb-3">
                    <button class="btn btn-outline-secondary btn-sm" 
                            type="button" 
                            data-bs-toggle="collapse" 
                            data-bs-target="#advancedOptions" 
                            aria-expanded="false" 
                            aria-controls="advancedOptions"
                            @onclick="() => showAdvancedOptions = !showAdvancedOptions">
                        <i class="bi bi-gear me-2"></i>
                        Erweiterte Optionen
                        <i class="bi @(showAdvancedOptions ? "bi-chevron-up" : "bi-chevron-down") ms-2"></i>
                    </button>
                </div>

                <!-- Advanced Options Content -->
                <div class="collapse" id="advancedOptions">
                    <div class="advanced-options-content mb-3">
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="documentId" class="form-label">Dokument ID (optional)</label>
                                <input @bind="documentId" type="text" class="form-control" id="documentId" 
                                       placeholder="Eindeutige ID für das Dokument">
                            </div>
                            <div class="col-md-6">
                                <label for="metadata" class="form-label">Metadaten (optional)</label>
                                <input @bind="metadata" type="text" class="form-control" id="metadata" 
                                       placeholder="Zusätzliche Informationen">
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="chunkSize" class="form-label">Chunk-Größe</label>
                                <input @bind="chunkSize" type="number" class="form-control" id="chunkSize" min="100" max="2000">
                                <div class="form-text">Standard: 300 Zeichen</div>
                            </div>
                            <div class="col-md-6">
                                <label for="chunkOverlap" class="form-label">Chunk-Überlappung</label>
                                <input @bind="chunkOverlap" type="number" class="form-control" id="chunkOverlap" min="0" max="500">
                                <div class="form-text">Standard: 20 Zeichen</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <button class="btn btn-success" @onclick="UploadDocument" disabled="@isUploading">
                    @if (isUploading)
                    {
                        <span class="spinner-border spinner-border-sm me-2" role="status"></span>
                    }
                    <i class="bi bi-upload"></i>
                    @(uploadMode == "text" ? "Text hochladen" : "Datei hochladen")
                </button>
            </div>
        }
    </div>

    <!-- Chat Messages -->
    <div class="chat-messages" @ref="chatContainer">
        @foreach (var message in messages)
        {
            <div class="message @message.Type" id="message-@message.Id">
                <div class="message-content">
                    @if (message.Type == "user")
                    {
                        <div class="user-avatar">
                            <i class="bi bi-person-fill"></i>
                        </div>
                    }
                    else
                    {
                        <div class="ai-avatar">
                            <i class="bi bi-robot"></i>
                        </div>
                    }
                    <div class="message-bubble">
                        @if (message.Type == "assistant")
                        {
                            @((MarkupString)MarkdownService.ToHtml(message.Content))
                        }
                        else
                        {
                            @((MarkupString)message.Content.Replace("\n", "<br>"))
                        }
                        
                        @if (message.Type == "assistant" && message.Results?.Count > 0)
                        {
                            var collapseId = $"sources-{message.Id}";
                            <div class="search-results mt-3">
                                <button class="btn btn-outline-secondary btn-sm sources-toggle" 
                                        type="button" 
                                        data-bs-toggle="collapse" 
                                        data-bs-target="#@collapseId" 
                                        aria-expanded="false" 
                                        aria-controls="@collapseId">
                                    <i class="bi bi-search me-2"></i>
                                    @message.Results.Count Quelle@(message.Results.Count != 1 ? "n" : "") anzeigen
                                    <i class="bi bi-chevron-down ms-2 collapse-icon"></i>
                                </button>
                                
                                <div class="collapse mt-2" id="@collapseId">
                                    <div class="sources-content">
                                        @foreach (var result in message.Results)
                                        {
                                            <div class="result-item">
                                                <div class="result-header">
                                                    <div class="result-meta-section">
                                                        <span class="result-score">
                                                            <i class="bi bi-graph-up"></i>
                                                            Relevanz: @result.Score.ToString("F2")
                                                        </span>
                                                        <span class="result-meta">
                                                            <i class="bi bi-file-text"></i>
                                                            @GetDisplayFileName(result.DocumentId) | Chunk @result.ChunkIndex
                                                        </span>
                                                    </div>
                                                    @if (result.IsFileAvailable || !string.IsNullOrEmpty(result.OriginalFileName))
                                                    {
                                                        <div class="result-actions">
                                                            <DownloadButton DocumentId="@result.DocumentId" 
                                                                          FileName="@result.OriginalFileName"
                                                                          OnError="@(async (string error) => await HandleDownloadError(error))"
                                                                          OnSuccess="@(async () => await HandleDownloadSuccess(result.OriginalFileName))" />
                                                        </div>
                                                    }
                                                </div>
                                                <div class="result-content">
                                                    @{
                                                        // Teile verfügbaren Kontext gleichmäßig auf die Quellen auf
                                                        var maxLengthPerSource = Math.Max(200, MaxContextLength / Math.Max(1, message.Results.Count));
                                                        var displayLength = Math.Min(maxLengthPerSource, result.Content.Length);
                                                        var displayContent = result.Content.Substring(0, displayLength);
                                                    }
                                                    @displayContent@(result.Content.Length > displayLength ? "..." : "")
                                                </div>
                                            </div>
                                        }
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                </div>
                <div class="message-time">
                    @message.Timestamp.ToString("HH:mm")
                </div>
            </div>
        }
        
        @if (isSearching)
        {
            <div class="message assistant">
                <div class="message-content">
                    <div class="ai-avatar">
                        <i class="bi bi-robot"></i>
                    </div>
                    <div class="message-bubble">
                        <div class="typing-indicator">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                </div>
            </div>
        }
    </div>

    <!-- Chat Input -->
    <div class="chat-input">
        @if (ChatHistoryEnabled && HasChatHistory())
        {
            <div class="chat-history-indicator">
                <div class="history-main">
                    <i class="bi bi-clock-history"></i>
                    <span class="text-muted">@GetChatHistoryIndicator()</span>
                </div>
                @if (GetUserMessagesCount() > MaxChatHistoryMessages * 2)
                {
                    <div class="context-limit-info">
                        <i class="bi bi-info-circle"></i>
                        <span>Nur die letzten @MaxChatHistoryMessages Nachrichten-Paare werden als Kontext verwendet</span>
                    </div>
                }
            </div>
        }
        <div class="input-group">
            <input @bind="currentMessage" @onkeypress="HandleKeyPress" type="text" class="form-control" 
                   placeholder="Stellen Sie eine Frage zu Ihren Dokumenten..." disabled="@isSearching">
            <button class="btn btn-primary" @onclick="SendMessage" disabled="@(isSearching || string.IsNullOrWhiteSpace(currentMessage))">
                @if (isSearching)
                {
                    <span class="spinner-border spinner-border-sm" role="status"></span>
                }
                else
                {
                    <i class="bi bi-send"></i>
                }
            </button>
        </div>
    </div>
</div>

<!-- Duplicate File Modal -->
@if (showDuplicateModal)
{
    <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="bi bi-exclamation-triangle text-warning me-2"></i>
                        Datei bereits vorhanden
                    </h5>
                </div>
                <div class="modal-body">
                    <p>Eine Datei mit dem Namen <strong>@duplicateFileName</strong> ist bereits vorhanden.</p>
                    <p>Möchten Sie die bestehende Datei überschreiben oder den Upload abbrechen?</p>
                    
                    <div class="alert alert-warning">
                        <i class="bi bi-info-circle me-2"></i>
                        <strong>Warnung:</strong> Das Überschreiben wird das bestehende Dokument und alle zugehörigen Chunks löschen.
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CancelUpload">
                        <i class="bi bi-x-circle me-2"></i>
                        Abbrechen
                    </button>
                    <button type="button" class="btn btn-warning" @onclick="OverwriteFile">
                        <i class="bi bi-arrow-repeat me-2"></i>
                        Überschreiben
                    </button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    private List<ChatMessage> messages = new();
    private string currentMessage = "";
    private string documentText = "";
    private string documentId = "";
    private string metadata = "";
    private string uploadMode = "text"; // "text" oder "file"
    private int chunkSize = 300;
    private int chunkOverlap = 20;
    private bool showUpload = false;
    private bool isSearching = false;
    private bool isUploading = false;
    private bool showAdvancedOptions = false;
    private ElementReference chatContainer;
    private IBrowserFile? selectedFile;
    
    // Duplikatsprüfung
    private bool showDuplicateModal = false;
    private string? duplicateFileName = null;
    private string? existingDocumentId = null;
    
    // Cache für DocumentId -> FileName Mapping
    private Dictionary<string, string> documentNameCache = new();
    
    // Scroll-Management
    private int lastMessageCount = 0;
    
    // Konfigurierbare Chat-Parameter
    private int MaxSourcesForAnswer => Configuration.GetValue<int>("ChatService:MaxSourcesForAnswer", 5);
    private int MaxContextLength => Configuration.GetValue<int>("ChatService:MaxContextLength", 12000);
    
    // Chatverlauf-Konfiguration
    private bool ChatHistoryEnabled => Configuration.GetValue<bool>("ChatService:ChatHistoryEnabled", true);
    private int MaxChatHistoryMessages => Configuration.GetValue<int>("ChatService:MaxChatHistoryMessages", 5);
    private int ChatHistoryContextPercentage => Configuration.GetValue<int>("ChatService:ChatHistoryContextPercentage", 30);
    
    // Konfigurierbarer Upload-Limit
    private int MaxUploadSizeMB => Configuration.GetValue<int>("DriftMindApi:MaxUploadSizeMB", 3);
    private long MaxUploadSizeBytes => MaxUploadSizeMB * 1024 * 1024;

    protected override void OnInitialized()
    {
        messages.Add(new ChatMessage
        {
            Type = "assistant",
            Content = "Hallo! Ich bin Ihr DriftMind AI Assistant. Sie können Dokumente hochladen (.txt, .md, .pdf, .docx) oder Text direkt eingeben und dann Fragen dazu stellen. Wie kann ich Ihnen helfen?",
            Timestamp = DateTime.Now
        });
        
        lastMessageCount = messages.Count;
    }

    private void ToggleUpload()
    {
        showUpload = !showUpload;
    }

    private void SetUploadMode(string mode)
    {
        uploadMode = mode;
        selectedFile = null;
        documentText = "";
    }

    private async Task HandleFileSelection(InputFileChangeEventArgs e)
    {
        selectedFile = e.File;
        
        // Validate file size (configurable limit)
        if (selectedFile.Size > MaxUploadSizeBytes)
        {
            messages.Add(new ChatMessage
            {
                Type = "assistant",
                Content = $"Die ausgewählte Datei ist zu groß. Das Maximum sind {MaxUploadSizeMB}MB.",
                Timestamp = DateTime.Now
            });
            selectedFile = null;
            StateHasChanged();
            await ScrollToNewMessage();
            return;
        }

        // Validate file extension
        var allowedExtensions = new[] { ".txt", ".md", ".pdf", ".docx" };
        var fileExtension = Path.GetExtension(selectedFile.Name).ToLowerInvariant();
        
        if (!allowedExtensions.Contains(fileExtension))
        {
            messages.Add(new ChatMessage
            {
                Type = "assistant",
                Content = $"Dateiformat '{fileExtension}' wird nicht unterstützt. Erlaubte Formate: .txt, .md, .pdf, .docx",
                Timestamp = DateTime.Now
            });
            selectedFile = null;
            StateHasChanged();
            await ScrollToNewMessage();
            return;
        }

        StateHasChanged();
    }

    private async Task UploadDocument()
    {
        if (isUploading) return;
        
        isUploading = true;
        StateHasChanged();
        
        try
        {
            if (uploadMode == "text" && !string.IsNullOrWhiteSpace(documentText))
            {
                // Text Upload - Erstelle temporäre Datei und lade sie hoch
                var response = await ApiService.UploadTextAsFileAsync(
                    documentText,
                    string.IsNullOrWhiteSpace(documentId) ? null : documentId,
                    string.IsNullOrWhiteSpace(metadata) ? null : metadata,
                    chunkSize,
                    chunkOverlap
                );
                
                if (response != null && response.Success)
                {
                    messages.Add(new ChatMessage
                    {
                        Type = "assistant",
                        Content = $"Text erfolgreich als Datei hochgeladen! Dateiname: {response.FileName}, Dokument-ID: {response.DocumentId}. Es wurden {response.ChunksCreated} Chunks erstellt. Sie können jetzt Fragen zu diesem Inhalt stellen.",
                        Timestamp = DateTime.Now
                    });
                }
                else
                {
                    messages.Add(new ChatMessage
                    {
                        Type = "assistant",
                        Content = "Fehler beim Hochladen des Textes. Bitte überprüfen Sie, ob die DriftMind API läuft und erreichbar ist.",
                        Timestamp = DateTime.Now
                    });
                }
            }
            else if (selectedFile != null)
            {
                // Prüfe zuerst auf Duplikate
                var (exists, existingDocId) = await CheckFileExists(selectedFile.Name);
                if (exists && !string.IsNullOrEmpty(existingDocId))
                {
                    // Zeige Duplikat-Modal
                    duplicateFileName = selectedFile.Name;
                    existingDocumentId = existingDocId;
                    showDuplicateModal = true;
                    isUploading = false;
                    StateHasChanged();
                    return;
                }

                // File Upload
                await PerformFileUpload();
            }
            
            // Reset form nach erfolgreichem Upload
            ResetUploadForm();
        }
        finally
        {
            isUploading = false;
            StateHasChanged();
            await ScrollToNewMessage();
        }
    }

    private void ResetUploadForm()
    {
        documentText = "";
        selectedFile = null;
        documentId = "";
        metadata = "";
        showUpload = false;
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !isSearching && !string.IsNullOrWhiteSpace(currentMessage))
        {
            await SendMessage();
        }
    }

    private async Task SendMessage()
    {
        if (isSearching || string.IsNullOrWhiteSpace(currentMessage)) return;
        
        var userMessage = currentMessage.Trim();
        currentMessage = "";
        
        messages.Add(new ChatMessage
        {
            Type = "user",
            Content = userMessage,
            Timestamp = DateTime.Now
        });
        
        isSearching = true;
        StateHasChanged();
        await ScrollToBottom(); // Für User-Nachrichten bleibt ScrollToBottom
        
        try
        {
            var searchRequest = new SearchRequest
            {
                Query = userMessage,
                MaxResults = MaxSourcesForAnswer,
                UseSemanticSearch = true,
                IncludeAnswer = true,
                ChatHistory = ChatHistoryEnabled ? BuildChatHistory() : null
            };
            
            var response = await ApiService.SearchAsync(searchRequest);
            
            if (response != null && response.Success)
            {
                var chatMessage = new ChatMessage
                {
                    Type = "assistant",
                    Content = response.GeneratedAnswer ?? "Keine Antwort generiert.",
                    Timestamp = DateTime.Now,
                    Results = response.Results?
                        .Select(r => new SearchResult
                        {
                            Content = r.Content,
                            DocumentId = r.DocumentId,
                            ChunkIndex = r.ChunkIndex,
                            Score = r.Score,
                            OriginalFileName = r.OriginalFileName,
                            IsFileAvailable = r.IsFileAvailable
                        }).ToList() ?? new List<SearchResult>()
                };
                
                messages.Add(chatMessage);
                
                // Lade Dateinamen für alle unique DocumentIds
                if (chatMessage.Results?.Count > 0)
                {
                    var uniqueDocumentIds = chatMessage.Results.Select(r => r.DocumentId).Distinct().ToList();
                    _ = Task.Run(async () =>
                    {
                        foreach (var docId in uniqueDocumentIds)
                        {
                            await GetDocumentFileName(docId);
                        }
                        await InvokeAsync(StateHasChanged);
                    });
                }
            }
            else
            {
                messages.Add(new ChatMessage
                {
                    Type = "assistant",
                    Content = "Entschuldigung, ich konnte keine Antwort auf Ihre Frage finden. Stellen Sie sicher, dass Sie relevante Dokumente hochgeladen haben.",
                    Timestamp = DateTime.Now
                });
            }
        }
        catch (Exception ex)
        {
            messages.Add(new ChatMessage
            {
                Type = "assistant",
                Content = $"Ein Fehler ist aufgetreten: {ex.Message}",
                Timestamp = DateTime.Now
            });
        }
        finally
        {
            isSearching = false;
            StateHasChanged();
            await ScrollToNewMessage(); // Für Assistant-Antworten zum Anfang der neuen Nachricht scrollen
        }
    }

    private async Task ScrollToBottom()
    {
        await Task.Delay(100);
        await JSRuntime.InvokeVoidAsync("scrollToBottom", chatContainer);
    }
    
    private async Task ScrollToNewMessage()
    {
        // Prüfe, ob eine neue Assistant-Nachricht hinzugefügt wurde
        if (messages.Count > lastMessageCount && messages.LastOrDefault()?.Type == "assistant")
        {
            await Task.Delay(150); // Kurz warten, damit das DOM aktualisiert wird
            
            var lastMessage = messages.LastOrDefault();
            if (lastMessage != null)
            {
                try
                {
                    // Erstelle eine eindeutige ID für die letzte Nachricht
                    var messageId = $"message-{lastMessage.Id}";
                    await JSRuntime.InvokeVoidAsync("scrollToMessage", messageId);
                }
                catch
                {
                    // Fallback: Normale Scroll-Funktion falls JavaScript fehlschlägt
                    await ScrollToBottom();
                }
            }
        }
        else
        {
            // Für User-Nachrichten oder andere Fälle: normal nach unten scrollen
            await ScrollToBottom();
        }
        
        lastMessageCount = messages.Count;
    }

    private List<DriftMindWeb.Services.ChatMessage>? BuildChatHistory()
    {
        if (!ChatHistoryEnabled || messages.Count <= 1) // Erste Begrüßungsnachricht nicht mitzählen
            return null;

        // Hole die letzten Nachrichten (exklusive der ersten Begrüßungsnachricht)
        var relevantMessages = messages
            .Skip(1) // Überspringe die erste Begrüßungsnachricht
            .Where(m => m.Type == "user" || m.Type == "assistant")
            .OrderBy(m => m.Timestamp)
            .TakeLast(MaxChatHistoryMessages * 2) // User + Assistant Paare
            .ToList();

        if (!relevantMessages.Any())
            return null;

        // Konvertiere zu ChatMessage (API-Format)
        var chatHistory = relevantMessages.Select(m => new DriftMindWeb.Services.ChatMessage
        {
            Role = m.Type,
            Content = TruncateForChatHistory(m.Content),
            Timestamp = m.Timestamp
        }).ToList();

        return chatHistory;
    }

    private string TruncateForChatHistory(string content)
    {
        // Berechne die maximale Länge pro Nachricht basierend auf dem Kontextprozentsatz
        var chatHistoryContextLength = (int)(MaxContextLength * (ChatHistoryContextPercentage / 100.0));
        var maxLengthPerMessage = Math.Max(100, chatHistoryContextLength / Math.Max(1, MaxChatHistoryMessages * 2));

        if (content.Length <= maxLengthPerMessage)
            return content;

        return content.Substring(0, maxLengthPerMessage) + "...";
    }

    private bool HasChatHistory()
    {
        return messages.Count > 1; // Mehr als nur die Begrüßungsnachricht
    }

    private int GetChatHistoryCount()
    {
        return Math.Max(0, messages.Count - 1); // Begrüßungsnachricht nicht mitzählen
    }

    private int GetUserMessagesCount()
    {
        return messages.Where(m => m.Type == "user" || m.Type == "assistant").Count() - 1; // Ohne Begrüßung
    }

    private string GetChatHistoryIndicator()
    {
        if (!ChatHistoryEnabled || !HasChatHistory())
            return "";

        var totalMessages = GetUserMessagesCount();
        var contextMessages = Math.Min(totalMessages, MaxChatHistoryMessages * 2); // User+Assistant Paare

        if (totalMessages <= MaxChatHistoryMessages * 2)
        {
            return $"Mit Chatverlauf ({totalMessages} Nachrichten)";
        }
        else
        {
            return $"Mit Chatverlauf ({contextMessages} von {totalMessages} Nachrichten im Kontext)";
        }
    }

    private string GetNewChatButtonText()
    {
        if (!HasChatHistory())
            return "Neuer Chat";

        var totalMessages = GetUserMessagesCount();

        if (!ChatHistoryEnabled)
        {
            return $"Neuer Chat ({totalMessages} Nachrichten)";
        }

        var contextMessages = Math.Min(totalMessages, MaxChatHistoryMessages * 2);

        if (totalMessages <= MaxChatHistoryMessages * 2)
        {
            return $"Neuer Chat ({totalMessages} im Verlauf)";
        }
        else
        {
            return $"Neuer Chat ({contextMessages}/{totalMessages} im Kontext)";
        }
    }

    private async Task ClearChatHistory()
    {
        // Behalte nur die erste Begrüßungsnachricht
        var welcomeMessage = messages.FirstOrDefault();
        messages.Clear();
        
        if (welcomeMessage != null)
        {
            messages.Add(welcomeMessage);
        }
        else
        {
            // Fallback: Erstelle eine neue Begrüßungsnachricht
            messages.Add(new ChatMessage
            {
                Type = "assistant",
                Content = "Hallo! Ich bin Ihr DriftMind AI Assistant. Sie können Dokumente hochladen (.txt, .md, .pdf, .docx) oder Text direkt eingeben und dann Fragen dazu stellen. Wie kann ich Ihnen helfen?",
                Timestamp = DateTime.Now
            });
        }
        
        StateHasChanged();
        await ScrollToNewMessage();
    }

    private string FormatFileSize(long bytes)
    {
        if (bytes == 0) return "0 B";
        
        string[] suffixes = { "B", "KB", "MB", "GB" };
        int suffixIndex = 0;
        double size = bytes;

        while (size >= 1024 && suffixIndex < suffixes.Length - 1)
        {
            size /= 1024;
            suffixIndex++;
        }

        return $"{size:F1} {suffixes[suffixIndex]}";
    }

    private async Task<string> GetDocumentFileName(string documentId)
    {
        // Prüfe Cache zuerst
        if (documentNameCache.TryGetValue(documentId, out var cachedName))
        {
            return cachedName;
        }

        try
        {
            // Lade Dokument-Info von der API
            var response = await ApiService.GetDocumentsAsync(1, 0, documentId);
            if (response?.Success == true && response.Documents.Count > 0)
            {
                var document = response.Documents[0];
                var fileName = !string.IsNullOrEmpty(document.FileName) ? document.FileName : documentId;
                
                // Cache das Ergebnis
                documentNameCache[documentId] = fileName;
                return fileName;
            }
        }
        catch (Exception)
        {
            // Bei Fehler verwende DocumentId als Fallback
        }

        // Fallback: verwende DocumentId
        documentNameCache[documentId] = documentId;
        return documentId;
    }

    private string GetDisplayFileName(string documentId)
    {
        // Verwende Cache oder DocumentId als Fallback
        return documentNameCache.TryGetValue(documentId, out var cachedName) ? cachedName : documentId;
    }

    private async Task<(bool exists, string? documentId)> CheckFileExists(string fileName)
    {
        try
        {
            // Lade alle Dokumente und suche nach dem Dateinamen
            var response = await ApiService.GetDocumentsAsync(100, 0, null);
            if (response?.Success == true && response.Documents.Count > 0)
            {
                var existingDoc = response.Documents.FirstOrDefault(d => 
                    string.Equals(d.FileName, fileName, StringComparison.OrdinalIgnoreCase));
                
                if (existingDoc != null)
                {
                    return (true, existingDoc.DocumentId);
                }
            }
        }
        catch (Exception)
        {
            // Bei Fehler nehmen wir an, dass die Datei nicht existiert
        }

        return (false, null);
    }

    private async Task<bool> PerformFileUpload()
    {
        if (selectedFile == null) return false;

        try
        {
            using var stream = selectedFile.OpenReadStream(maxAllowedSize: MaxUploadSizeBytes);
            
            var response = await ApiService.UploadFileAsync(
                stream, 
                selectedFile.Name, 
                string.IsNullOrWhiteSpace(documentId) ? null : documentId,
                string.IsNullOrWhiteSpace(metadata) ? null : metadata,
                chunkSize,
                chunkOverlap
            );
            
            if (response != null && response.Success)
            {
                messages.Add(new ChatMessage
                {
                    Type = "assistant",
                    Content = $"Datei '{response.FileName}' erfolgreich hochgeladen! Dokument-ID: {response.DocumentId}. Dateigröße: {FormatFileSize(response.FileSizeBytes)}. Es wurden {response.ChunksCreated} Chunks erstellt. Sie können jetzt Fragen zu diesem Inhalt stellen.",
                    Timestamp = DateTime.Now
                });
                return true;
            }
            else
            {
                messages.Add(new ChatMessage
                {
                    Type = "assistant",
                    Content = "Fehler beim Hochladen der Datei. Bitte überprüfen Sie, ob die DriftMind API läuft und erreichbar ist.",
                    Timestamp = DateTime.Now
                });
                return false;
            }
        }
        catch (Exception ex)
        {
            messages.Add(new ChatMessage
            {
                Type = "assistant",
                Content = $"Fehler beim Hochladen der Datei: {ex.Message}",
                Timestamp = DateTime.Now
            });
            return false;
        }
    }

    private async Task OverwriteFile()
    {
        showDuplicateModal = false;
        
        try
        {
            // Lösche erst das existierende Dokument
            if (!string.IsNullOrEmpty(existingDocumentId))
            {
                await ApiService.DeleteDocumentAsync(existingDocumentId);
            }
            
            // Führe den Upload durch
            var uploadSuccess = await PerformFileUpload();
            
            // Reset Form nur bei erfolgreichem Upload
            if (uploadSuccess)
            {
                ResetUploadForm();
                await ScrollToNewMessage();
            }
        }
        finally
        {
            // Reset Modal-Variablen
            duplicateFileName = null;
            existingDocumentId = null;
            isUploading = false;
            StateHasChanged();
        }
    }

    private void CancelUpload()
    {
        showDuplicateModal = false;
        duplicateFileName = null;
        existingDocumentId = null;
        isUploading = false;
        StateHasChanged();
    }

    private Task HandleDownloadError(string error)
    {
        messages.Add(new ChatMessage
        {
            Type = "system",
            Content = $"Download-Fehler: {error}",
            Timestamp = DateTime.Now
        });
        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task HandleDownloadSuccess(string? fileName)
    {
        // Optional: Success-Meldung anzeigen
        // messages.Add(new ChatMessage
        // {
        //     Type = "system",
        //     Content = $"Download von '{fileName ?? "Dokument"}' gestartet.",
        //     Timestamp = DateTime.Now
        // });
        // StateHasChanged();
        return Task.CompletedTask;
    }

    public class ChatMessage
    {
        public string Id { get; set; } = Guid.NewGuid().ToString("N")[..8]; // Kurze eindeutige ID
        public string Type { get; set; } = ""; // "user" oder "assistant"
        public string Content { get; set; } = "";
        public DateTime Timestamp { get; set; }
        public List<SearchResult>? Results { get; set; }
    }

    public class SearchResult
    {
        public string Content { get; set; } = "";
        public string DocumentId { get; set; } = "";
        public int ChunkIndex { get; set; }
        public double Score { get; set; }
        public string? OriginalFileName { get; set; }
        public bool IsFileAvailable { get; set; }
    }
}
