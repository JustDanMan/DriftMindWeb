@page "/chat"
@using DriftMindWeb.Services
@using Microsoft.AspNetCore.Components.Forms
@inject IDriftMindApiService ApiService
@inject IMarkdownService MarkdownService
@inject ITimezoneService TimezoneService
@inject IJSRuntime JSRuntime
@inject IConfiguration Configuration
@inject ProtectedSessionStorage ProtectedSessionStorage
@rendermode InteractiveServer

<PageTitle>DriftMind Chat</PageTitle>

<div class="chat-container">
    <div class="chat-header @(ShouldHideHeader ? "hidden" : "")">
        <h2>
            <i class="bi bi-chat-dots"></i>
            DriftMind AI Assistant
        </h2>
        <p class="text-muted">Laden Sie Dokumente hoch oder stellen Sie Fragen zu Ihren Inhalten</p>
    </div>

    <!-- Upload Section -->
    <div class="upload-section @(showUpload ? "expanded" : "collapsed")">
        <div class="upload-header">
            <div class="upload-buttons">
                <button class="btn btn-outline-primary mb-3" @onclick="ToggleUpload">
                    <i class="bi bi-cloud-upload"></i>
                    @(showUpload ? "Upload verbergen" : "Dokument hochladen")
                </button>
                @if (ChatHistoryEnabled && HasChatHistory())
                {
                    <button class="btn btn-outline-primary mb-3" @onclick="ClearChatHistory" title="Chat-Verlauf löschen">
                        <i class="bi bi-trash3"></i>
                        @GetNewChatButtonText()
                    </button>
                }
            </div>
        </div>
        
        @if (showUpload)
        {
            <div class="upload-form">
                <div class="upload-tabs">
                    <button type="button" class="btn @(uploadMode == "file" ? "btn-primary" : "btn-outline-primary") me-2" 
                            @onclick="@(() => SetUploadMode("file"))">
                        <i class="bi bi-file-earmark-arrow-up"></i> Datei hochladen
                    </button>
                    <button type="button" class="btn @(uploadMode == "text" ? "btn-primary" : "btn-outline-primary")" 
                            @onclick="@(() => SetUploadMode("text"))">
                        <i class="bi bi-textarea-t"></i> Text eingeben
                    </button>
                </div>

                @if (uploadMode == "text")
                {
                    <div class="text-upload-section">
                        <div class="mb-3">
                            <label for="documentText" class="form-label">Text/Dokument</label>
                            <textarea value="@documentText" 
                                      @oninput="OnTextInput"
                                      maxlength="@MAX_TEXT_LENGTH"
                                      class="form-control" 
                                      id="documentText" rows="6" 
                                      placeholder="Fügen Sie hier Ihren Text ein..."></textarea>
                            
                            <!-- Character counter -->
                            <div class="form-text d-flex justify-content-between">
                                <span>
                                    @documentText.Length.ToString("N0") / @MAX_TEXT_LENGTH.ToString("N0") Zeichen
                                </span>
                                @if (documentText.Length > WARNING_TEXT_LENGTH)
                                {
                                    <span class="text-warning">
                                        <i class="bi bi-exclamation-triangle"></i>
                                        Text wird groß
                                    </span>
                                }
                            </div>
                            
                            <!-- Warnings -->
                            @if (documentText.Length > WARNING_TEXT_LENGTH)
                            {
                                <div class="alert alert-warning mt-2">
                                    <i class="bi bi-exclamation-triangle me-2"></i>
                                    <strong>Hinweis:</strong> Text wird groß (@documentText.Length.ToString("N0") Zeichen). 
                                    <strong>Für größere Texte verwenden Sie bitte den Datei-Upload</strong> - das ist stabiler und effizienter.
                                </div>
                            }
                        </div>
                    </div>
                }
                else
                {
                    <div class="file-upload-section">
                        <div class="mb-3">
                            <label for="fileInput" class="form-label">Datei auswählen</label>
                            <InputFile OnChange="HandleFileSelection" class="form-control" id="fileInput" 
                                      accept=".txt,.md,.pdf,.docx" />
                            <div class="form-text">
                                Unterstützte Formate: .txt, .md, .pdf, .docx (max. @MaxUploadSizeMB MB)
                            </div>
                            @if (selectedFile != null)
                            {
                                <div class="selected-file-info mt-2">
                                    <div class="alert alert-info">
                                        <i class="bi bi-file-earmark"></i>
                                        <strong>@selectedFile.Name</strong> 
                                        <span class="text-muted">(@FormatFileSize(selectedFile.Size))</span>
                                    </div>
                                </div>
                            }
                        </div>
                    </div>
                }
                
                <!-- Advanced Options Toggle -->
                <div class="mb-3">
                    <button class="btn btn-outline-secondary btn-sm" 
                            type="button" 
                            data-bs-toggle="collapse" 
                            data-bs-target="#advancedOptions" 
                            aria-expanded="false" 
                            aria-controls="advancedOptions"
                            @onclick="() => showAdvancedOptions = !showAdvancedOptions">
                        <i class="bi bi-gear me-2"></i>
                        Erweiterte Optionen
                        <i class="bi @(showAdvancedOptions ? "bi-chevron-up" : "bi-chevron-down") ms-2"></i>
                    </button>
                </div>

                <!-- Advanced Options Content -->
                <div class="collapse" id="advancedOptions">
                    <div class="advanced-options-content mb-3">
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="documentId" class="form-label">Dokument ID (optional)</label>
                                <input @bind="documentId" type="text" class="form-control" id="documentId" 
                                       placeholder="Eindeutige ID für das Dokument">
                            </div>
                            <div class="col-md-6">
                                <label for="metadata" class="form-label">Metadaten (optional)</label>
                                <input @bind="metadata" type="text" class="form-control" id="metadata" 
                                       placeholder="Zusätzliche Informationen">
                            </div>
                        </div>
                        
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="chunkSize" class="form-label">Chunk-Größe</label>
                                <input @bind="chunkSize" type="number" class="form-control" id="chunkSize" min="100" max="2000">
                                <div class="form-text">Standard: 300 Zeichen</div>
                            </div>
                            <div class="col-md-6">
                                <label for="chunkOverlap" class="form-label">Chunk-Überlappung</label>
                                <input @bind="chunkOverlap" type="number" class="form-control" id="chunkOverlap" min="0" max="500">
                                <div class="form-text">Standard: 20 Zeichen</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <button class="btn btn-success" @onclick="UploadDocument" disabled="@isUploading">
                    @if (isUploading)
                    {
                        <span class="spinner-border spinner-border-sm me-2" role="status"></span>
                    }
                    <i class="bi bi-upload"></i>
                    @(uploadMode == "text" ? "Text hochladen" : "Datei hochladen")
                </button>
            </div>
        }
    </div>

    <!-- Chat Messages -->
    <div class="chat-messages" @ref="chatContainer">
        @foreach (var message in messages)
        {
            <div class="message @message.Type" id="message-@message.Id">
                <div class="message-content">
                    @if (message.Type == "user")
                    {
                        <div class="user-avatar">
                            <i class="bi bi-person-fill"></i>
                        </div>
                    }
                    else
                    {
                        <div class="ai-avatar">
                            <i class="bi bi-robot"></i>
                        </div>
                    }
                    <div class="message-bubble">
                        <div class="message-header">
                            <div class="message-sender">
                                @if (message.Type == "user")
                                {
                                    <span>Sie</span>
                                    @if (!isSearching)
                                    {
                                        <button class="resend-btn" 
                                                @onclick="@(() => ResendMessage(message))"
                                                title="Nachricht erneut senden">
                                            <i class="bi bi-arrow-clockwise"></i>
                                        </button>
                                    }
                                }
                                else
                                {
                                    <span>DriftMind</span>
                                }
                            </div>
                            <div class="message-actions">
                                <div class="message-timestamp">
                                    <i class="bi bi-clock"></i>
                                    @GetFormattedTime(message.Timestamp)
                                </div>
                            </div>
                        </div>
                        
                        <div class="message-text">
                            @if (message.Type == "assistant")
                            {
                                @((MarkupString)MarkdownService.ToHtml(message.Content))
                            }
                            else
                            {
                                @((MarkupString)message.Content.Replace("\n", "<br>"))
                            }
                        </div>
                        
                        @if (message.Type == "assistant" && message.Results?.Count > 0)
                        {
                            var collapseId = $"sources-{message.Id}";
                            <div class="search-results mt-3">
                                <button class="btn btn-outline-secondary btn-sm sources-toggle" 
                                        type="button" 
                                        data-bs-toggle="collapse" 
                                        data-bs-target="#@collapseId" 
                                        aria-expanded="false" 
                                        aria-controls="@collapseId">
                                    <i class="bi bi-search me-2"></i>
                                    @message.Results.Count Quelle@(message.Results.Count != 1 ? "n" : "") anzeigen
                                    <i class="bi bi-chevron-down ms-2 collapse-icon"></i>
                                </button>
                                
                                <div class="collapse mt-2" id="@collapseId">
                                    <div class="sources-content">
                                        @foreach (var result in message.Results)
                                        {
                                            <div class="result-item">
                                                <div class="result-header">
                                                    <div class="result-meta-section">
                                                        <span class="result-score">
                                                            <i class="bi bi-graph-up"></i>
                                                            Relevanz: @result.Score.ToString("F2")
                                                        </span>
                                                        <span class="result-meta">
                                                            <i class="bi bi-file-text"></i>
                                                            @(result.OriginalFileName ?? result.DocumentId) | Chunk @result.ChunkIndex
                                                        </span>
                                                    </div>
                                                    @if (result.IsFileAvailable || !string.IsNullOrEmpty(result.OriginalFileName))
                                                    {
                                                        <div class="result-actions">
                                                            <DownloadButton DocumentId="@result.DocumentId" 
                                                                          FileName="@result.OriginalFileName"
                                                                          OnError="@(async (string error) => await HandleDownloadError(error))"
                                                                          OnSuccess="@(async () => await HandleDownloadSuccess(result.OriginalFileName))" />
                                                        </div>
                                                    }
                                                </div>
                                                <div class="result-content">
                                                    @{
                                                        // Split available context evenly across sources
                                                        var maxLengthPerSource = Math.Max(200, MaxContextLength / Math.Max(1, message.Results.Count));
                                                        var displayLength = Math.Min(maxLengthPerSource, result.Content.Length);
                                                        var displayContent = result.Content.Substring(0, displayLength);
                                                    }
                                                    @displayContent@(result.Content.Length > displayLength ? "..." : "")
                                                </div>
                                            </div>
                                        }
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                </div>
            </div>
        }
        
        @if (isSearching)
        {
            <div class="message assistant">
                <div class="message-content">
                    <div class="ai-avatar">
                        <i class="bi bi-robot"></i>
                    </div>
                    <div class="message-bubble typing-bubble">
                        <div class="message-header typing-header">
                            <div class="message-sender">
                                <span>DriftMind</span>
                            </div>
                        </div>
                        
                        <div class="message-text">
                            <div class="typing-indicator">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        }
    </div>

    <!-- Chat Input -->
    <div class="chat-input">
        @if (ChatHistoryEnabled && HasChatHistory())
        {
            <div class="chat-history-indicator">
                <div class="history-main">
                    <i class="bi bi-clock-history"></i>
                    <span class="text-muted">@GetChatHistoryIndicator()</span>
                </div>
                @if (GetUserMessagesCount() > MaxChatHistoryMessages * 2)
                {
                    <div class="context-limit-info">
                        <i class="bi bi-info-circle"></i>
                        <span>Nur die letzten @MaxChatHistoryMessages Nachrichten-Paare werden als Kontext verwendet</span>
                    </div>
                }
            </div>
        }
        @if (ChatHistoryEnabled && isChatHistoryTooLarge)
        {
            <div class="alert alert-warning mt-2">
                <i class="bi bi-exclamation-triangle me-2"></i>
                <strong>Hinweis:</strong> Der Chat-Verlauf ist groß (@FormatFileSize(chatHistorySizeBytes)).
                Er überschreitet @FormatFileSize(ChatHistoryMaxBytes) und wird daher nicht persistent gespeichert.
            </div>
        }
        <div class="input-group">
            <input @bind="currentMessage" @bind:event="oninput" @onkeydown="HandleKeyDown" type="text" class="form-control" 
                   placeholder="Stellen Sie eine Frage zu Ihren Dokumenten..." disabled="@isSearching">
            <button class="btn btn-primary" @onclick="SendMessage" disabled="@(isSearching || string.IsNullOrWhiteSpace(currentMessage))">
                @if (isSearching)
                {
                    <span class="spinner-border spinner-border-sm" role="status"></span>
                }
                else
                {
                    <i class="bi bi-send"></i>
                }
            </button>
        </div>
    </div>
</div>

<!-- Duplicate File Modal -->
@if (showDuplicateModal)
{
    <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="bi bi-exclamation-triangle text-warning me-2"></i>
                        Datei bereits vorhanden
                    </h5>
                </div>
                <div class="modal-body">
                    <p>Eine Datei mit dem Namen <strong>@duplicateFileName</strong> ist bereits vorhanden.</p>
                    <p>Möchten Sie die bestehende Datei überschreiben oder den Upload abbrechen?</p>
                    
                    <div class="alert alert-warning">
                        <i class="bi bi-info-circle me-2"></i>
                        <strong>Warnung:</strong> Das Überschreiben wird das bestehende Dokument und alle zugehörigen Chunks löschen.
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CancelUpload">
                        <i class="bi bi-x-circle me-2"></i>
                        Abbrechen
                    </button>
                    <button type="button" class="btn btn-warning" @onclick="OverwriteFile">
                        <i class="bi bi-arrow-repeat me-2"></i>
                        Überschreiben
                    </button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    private List<ChatMessage> messages = new();
    private string currentMessage = "";
    private string documentText = "";
    private string documentId = "";
    private string metadata = "";
    private string uploadMode = "file"; // "text" or "file"
    private int chunkSize = 300;
    private int chunkOverlap = 20;
    private bool showUpload = false;
    private bool isSearching = false;
    private bool isUploading = false;
    private bool showAdvancedOptions = false;
    private ElementReference chatContainer;
    private IBrowserFile? selectedFile;
    
    // Duplicate file check
    private bool showDuplicateModal = false;
    private string? duplicateFileName = null;
    private string? existingDocumentId = null;
    
    
    // Scroll management
    private int lastMessageCount = 0;

    // Hide intro header after first user message
    private bool ShouldHideHeader => messages.Any(m => m.Type == "user");
    
    // Configurable chat parameters
    private int MaxSourcesForAnswer => Configuration.GetValue<int>("ChatService:MaxSourcesForAnswer", 5);
    private int MaxContextLength => Configuration.GetValue<int>("ChatService:MaxContextLength", 12000);
    
    // Chat history configuration
    private bool ChatHistoryEnabled => Configuration.GetValue<bool>("ChatService:ChatHistoryEnabled", true);
    private int MaxChatHistoryMessages => Configuration.GetValue<int>("ChatService:MaxChatHistoryMessages", 5);
    private int ChatHistoryContextPercentage => Configuration.GetValue<int>("ChatService:ChatHistoryContextPercentage", 30);
    
    // Configurable upload limit
    private int MaxUploadSizeMB => Configuration.GetValue<int>("DriftMindApi:MaxUploadSizeMB", 3);
    private long MaxUploadSizeBytes => MaxUploadSizeMB * 1024 * 1024;
    
    // Text upload limits (pure Blazor-native)
    private const int MAX_TEXT_LENGTH = 15000;     // 15KB hard limit for circuit stability
    private const int WARNING_TEXT_LENGTH = 10000; // 10KB warning
    private const string WelcomeMessage = "Hallo! Ich bin Ihr DriftMind AI Assistant. Sie können Dokumente hochladen (.txt, .md, .pdf, .docx) oder Text direkt eingeben und dann Fragen dazu stellen. Wie kann ich Ihnen helfen?";
    
    // Helper properties for text upload
    private Timer? debounceTimer;
    private bool isUpdating = false;

    private void OnTextInput(ChangeEventArgs e)
    {
        // Prevent multiple parallel executions
        if (isUpdating) return;
        
        isUpdating = true;
        
        try
        {
            var newText = e.Value?.ToString() ?? "";
            
            // Truncate immediately if too long (prevents circuit overload)
            if (newText.Length > MAX_TEXT_LENGTH)
            {
                documentText = newText.Substring(0, MAX_TEXT_LENGTH);
                
                // Debounced warning - only every 2 seconds
                debounceTimer?.Dispose();
                debounceTimer = new Timer(ShowTruncationWarning, null, 2000, Timeout.Infinite);
            }
            else
            {
                documentText = newText;
            }
        }
        finally
        {
            isUpdating = false;
        }
        
        // No StateHasChanged() here - automatically called after event handler
    }

    private void ShowTruncationWarning(object? state)
    {
        InvokeAsync(() =>
        {
            messages.Add(new ChatMessage
            {
                Type = "assistant", 
                Content = $"⚠️ Text wurde auf {MAX_TEXT_LENGTH:N0} Zeichen gekürzt.",
                Timestamp = DateTime.Now
            });
            StateHasChanged();
        });
    }

    protected override void OnInitialized()
    {
        // Keep messages list empty initially to avoid flicker
        lastMessageCount = messages.Count;
    }

    public void Dispose()
    {
        debounceTimer?.Dispose();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await TimezoneService.InitializeAsync();
            await TryRestoreChatAsync();
        }

        // Safety net: In rare reconnect/rehydration cases firstRender path may be skipped
        // If there are still no messages, try restoring again when JSInterop is ready
        if (!firstRender && messages.Count == 0)
        {
            await TryRestoreChatAsync();
        }
    }

    private ChatMessage CreateAssistantMessage(string content)
    {
        return new ChatMessage
        {
            Type = "assistant",
            Content = content,
            Timestamp = DateTime.Now
        };
    }

    private void EnsureWelcomeMessage()
    {
        if (messages.Count == 0)
        {
            messages.Add(CreateAssistantMessage(WelcomeMessage));
        }
    }

    private async Task TryRestoreChatAsync()
    {
        // Try restore chat history from protected storage
        try
        {
            var stored = await ProtectedSessionStorage.GetAsync<List<ChatMessage>>(ChatStorageKey);
            if (stored.Success && stored.Value != null)
            {
                if (stored.Value.Count > 1)
                {
                    messages = stored.Value;
                }
                else
                {
                    // Only welcome or empty stored state -> ensure fresh welcome and clear persisted key
                    EnsureWelcomeMessage();
                    await ProtectedSessionStorage.DeleteAsync(ChatStorageKey);
                }
            }
            else
            {
                // Unreadable/invalid payload (e.g., session key changed) -> clear blocked key and show welcome
                await ProtectedSessionStorage.DeleteAsync(ChatStorageKey);
                EnsureWelcomeMessage();
            }
        }
        catch
        {
            // Fallback: ensure at least welcome message exists
            EnsureWelcomeMessage();
        }

        lastMessageCount = messages.Count;
        StateHasChanged();
        await ScrollToBottom();
    }

    private void ToggleUpload()
    {
        showUpload = !showUpload;
    }

    private void SetUploadMode(string mode)
    {
        uploadMode = mode;
        selectedFile = null;
        documentText = "";
    }

    private async Task HandleFileSelection(InputFileChangeEventArgs e)
    {
        selectedFile = e.File;
        
        // Validate file size (configurable limit)
        if (selectedFile.Size > MaxUploadSizeBytes)
        {
            messages.Add(new ChatMessage
            {
                Type = "assistant",
                Content = $"Die ausgewählte Datei ist zu groß. Das Maximum sind {MaxUploadSizeMB}MB.",
                Timestamp = DateTime.Now
            });
            await PersistChatAsync();
            selectedFile = null;
            StateHasChanged();
            await ScrollToNewMessage();
            return;
        }

        // Validate file extension
        var allowedExtensions = new[] { ".txt", ".md", ".pdf", ".docx" };
        var fileExtension = Path.GetExtension(selectedFile.Name).ToLowerInvariant();
        
        if (!allowedExtensions.Contains(fileExtension))
        {
            messages.Add(new ChatMessage
            {
                Type = "assistant",
                Content = $"Dateiformat '{fileExtension}' wird nicht unterstützt. Erlaubte Formate: .txt, .md, .pdf, .docx",
                Timestamp = DateTime.Now
            });
            await PersistChatAsync();
            selectedFile = null;
            StateHasChanged();
            await ScrollToNewMessage();
            return;
        }

        StateHasChanged();
    }

    private async Task UploadDocument()
    {
        if (isUploading) return;
        
        isUploading = true;
        StateHasChanged();
        
        try
        {
            if (uploadMode == "text" && !string.IsNullOrWhiteSpace(documentText))
            {
                // Text Upload - Create temporary file and upload it
                var response = await ApiService.UploadTextAsFileAsync(
                    documentText,
                    string.IsNullOrWhiteSpace(documentId) ? null : documentId,
                    string.IsNullOrWhiteSpace(metadata) ? null : metadata,
                    chunkSize,
                    chunkOverlap
                );
                
                if (response != null && response.Success)
                {
                    messages.Add(new ChatMessage
                    {
                        Type = "assistant",
                        Content = $"Text erfolgreich als Datei hochgeladen! Dateiname: {response.FileName}, Dokument-ID: {response.DocumentId}. Es wurden {response.ChunksCreated} Chunks erstellt. Sie können jetzt Fragen zu diesem Inhalt stellen.",
                        Timestamp = DateTime.Now
                    });
                    await PersistChatAsync();
                }
                else
                {
                    messages.Add(new ChatMessage
                    {
                        Type = "assistant",
                        Content = "Fehler beim Hochladen des Textes. Bitte überprüfen Sie, ob die DriftMind API läuft und erreichbar ist.",
                        Timestamp = DateTime.Now
                    });
                    await PersistChatAsync();
                }
            }
            else if (selectedFile != null)
            {
                // Check for duplicates first
                var (exists, existingDocId) = await CheckFileExists(selectedFile.Name);
                if (exists && !string.IsNullOrEmpty(existingDocId))
                {
                    // Show duplicate modal
                    duplicateFileName = selectedFile.Name;
                    existingDocumentId = existingDocId;
                    showDuplicateModal = true;
                    isUploading = false;
                    StateHasChanged();
                    return;
                }

                // File Upload
                await PerformFileUpload();
            }
            
            // Reset form after successful upload
            ResetUploadForm();
        }
        finally
        {
            isUploading = false;
            StateHasChanged();
            await ScrollToNewMessage();
        }
    }

    private void ResetUploadForm()
    {
        documentText = "";
        selectedFile = null;
        documentId = "";
        metadata = "";
        showUpload = false;
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            if (!isSearching && !string.IsNullOrWhiteSpace(currentMessage))
            {
                await SendMessage();
            }
        }
    }

    private async Task SendMessage()
    {
        if (isSearching || string.IsNullOrWhiteSpace(currentMessage)) return;
        
        var userMessage = currentMessage.Trim();
        await SendMessageInternal(userMessage);
    }
    
    private async Task ResendMessage(ChatMessage userMessage)
    {
        if (isSearching || userMessage.Type != "user") return;
        
    // Find the index of the message to resend
        var messageIndex = messages.FindIndex(m => m.Id == userMessage.Id);
        if (messageIndex == -1) return;
        
    // Remove all messages after this user message
        var messagesToKeep = messages.Take(messageIndex + 1).ToList();
        messages.Clear();
        messages.AddRange(messagesToKeep);
        
    // Update lastMessageCount for correct scroll logic
        lastMessageCount = messages.Count;
        
    // Persist the shortened chat history
        await PersistChatAsync();
        StateHasChanged();
        
    // Send the original message again
        await SendMessageInternal(userMessage.Content, isResend: true);
    }
    
    private async Task SendMessageInternal(string messageText, bool isResend = false)
    {
        if (isSearching || string.IsNullOrWhiteSpace(messageText)) return;
        
        // Reset currentMessage if coming from the original SendMessage method
        currentMessage = "";
        
        if (isResend)
        {
            // On resend, do not append an additional identical user bubble
            isSearching = true;
            StateHasChanged();
        }
        else
        {
            // Normal send: identical texts are allowed and will be displayed
            messages.Add(new ChatMessage
            {
                Type = "user",
                Content = messageText.Trim(),
                Timestamp = DateTime.Now
            });
            await PersistChatAsync();
            
            // Scroll to bottom for new messages
            isSearching = true;
            StateHasChanged();
            await ScrollToBottom();
        }
        
        try
        {
            var searchRequest = new SearchRequest
            {
                Query = messageText.Trim(),
                MaxResults = MaxSourcesForAnswer,
                UseSemanticSearch = true,
                IncludeAnswer = true,
                ChatHistory = ChatHistoryEnabled ? BuildChatHistory() : null
            };
            
            var response = await ApiService.SearchAsync(searchRequest);
            
            if (response != null && response.Success)
            {
                var chatMessage = new ChatMessage
                {
                    Type = "assistant",
                    Content = response.GeneratedAnswer ?? "Keine Antwort generiert.",
                    Timestamp = DateTime.Now,
                    Results = response.Results?
                        .Select(r => new SearchResult
                        {
                            Content = r.Content,
                            DocumentId = r.DocumentId,
                            ChunkIndex = r.ChunkIndex,
                            Score = r.Score,
                            OriginalFileName = r.OriginalFileName,
                            IsFileAvailable = r.IsFileAvailable
                        }).ToList() ?? new List<SearchResult>()
                };
                
                messages.Add(chatMessage);
                await PersistChatAsync();
                
                // Filenames are taken directly from OriginalFileName in the results; no additional fetch needed
            }
            else
            {
                messages.Add(new ChatMessage
                {
                    Type = "assistant",
                    Content = "Entschuldigung, ich konnte keine Antwort auf Ihre Frage finden. Stellen Sie sicher, dass Sie relevante Dokumente hochgeladen haben.",
                    Timestamp = DateTime.Now
                });
                await PersistChatAsync();
            }
        }
        catch (Exception ex)
        {
            messages.Add(new ChatMessage
            {
                Type = "assistant",
                Content = $"Ein Fehler ist aufgetreten: {ex.Message}",
                Timestamp = DateTime.Now
            });
            await PersistChatAsync();
        }
        finally
        {
            isSearching = false;
            StateHasChanged();
            await ScrollToNewMessage(); // For assistant answers scroll to beginning of new message
        }
    }

    private async Task ScrollToBottom()
    {
        await Task.Delay(100);
        await JSRuntime.InvokeVoidAsync("scrollToBottom", chatContainer);
    }
    
    private async Task ScrollToNewMessage()
    {
        // Check if a new assistant message was added
        if (messages.Count > lastMessageCount && messages.LastOrDefault()?.Type == "assistant")
        {
            await Task.Delay(150); // Wait briefly for DOM to update
            
            var lastMessage = messages.LastOrDefault();
            if (lastMessage != null)
            {
                try
                {
                    // Create unique ID for last message
                    var messageId = $"message-{lastMessage.Id}";
                    await JSRuntime.InvokeVoidAsync("scrollToMessage", messageId);
                }
                catch
                {
                    // Fallback: Normal scroll function if JavaScript fails
                    await ScrollToBottom();
                }
            }
        }
        else
        {
            // For user messages or other cases: scroll down normally
            await ScrollToBottom();
        }
        
        lastMessageCount = messages.Count;
    }

    private List<DriftMindWeb.Services.ChatMessage>? BuildChatHistory()
    {
        if (!ChatHistoryEnabled || messages.Count <= 1) // Don't include first welcome message
            return null;

        // Get last messages (excluding first welcome message)
        var relevantMessages = messages
            .Skip(1) // Skip first welcome message
            .Where(m => m.Type == "user" || m.Type == "assistant")
            .OrderBy(m => m.Timestamp)
            .TakeLast(MaxChatHistoryMessages * 2) // User + Assistant pairs
            .ToList();

        if (!relevantMessages.Any())
            return null;

        // Convert to ChatMessage (API format)
        var chatHistory = relevantMessages.Select(m => new DriftMindWeb.Services.ChatMessage
        {
            Role = m.Type,
            Content = TruncateForChatHistory(m.Content),
            Timestamp = m.Timestamp
        }).ToList();

        return chatHistory;
    }

    private string TruncateForChatHistory(string content)
    {
        // Calculate maximum length per message based on context percentage
        var chatHistoryContextLength = (int)(MaxContextLength * (ChatHistoryContextPercentage / 100.0));
        var maxLengthPerMessage = Math.Max(100, chatHistoryContextLength / Math.Max(1, MaxChatHistoryMessages * 2));

        if (content.Length <= maxLengthPerMessage)
            return content;

        return content.Substring(0, maxLengthPerMessage) + "...";
    }

    private bool HasChatHistory()
    {
        return messages.Count > 1; // More than just welcome message
    }

    private int GetChatHistoryCount()
    {
        return Math.Max(0, messages.Count - 1); // Don't count welcome message
    }

    private int GetUserMessagesCount()
    {
        return messages.Where(m => m.Type == "user" || m.Type == "assistant").Count() - 1; // Without welcome
    }

    private string GetChatHistoryIndicator()
    {
        if (!ChatHistoryEnabled || !HasChatHistory())
            return "";

        var totalMessages = GetUserMessagesCount();
        var contextMessages = Math.Min(totalMessages, MaxChatHistoryMessages * 2); // User+Assistant pairs

        if (totalMessages <= MaxChatHistoryMessages * 2)
        {
            return $"Mit Chatverlauf ({totalMessages} Nachrichten)";
        }
        else
        {
            return $"Mit Chatverlauf ({contextMessages} von {totalMessages} Nachrichten im Kontext)";
        }
    }

    private string GetNewChatButtonText()
    {
        if (!HasChatHistory())
            return "Neuer Chat";

        var totalMessages = GetUserMessagesCount();

        if (!ChatHistoryEnabled)
        {
            return $"Neuer Chat ({totalMessages} Nachrichten)";
        }

        var contextMessages = Math.Min(totalMessages, MaxChatHistoryMessages * 2);

        if (totalMessages <= MaxChatHistoryMessages * 2)
        {
            return $"Neuer Chat ({totalMessages} im Verlauf)";
        }
        else
        {
            return $"Neuer Chat ({contextMessages}/{totalMessages} im Kontext)";
        }
    }

    private async Task ClearChatHistory()
    {
        // Always create a fresh welcome message (new timestamp)
        messages.Clear();
        EnsureWelcomeMessage();

        // Clear persisted history so only-welcome is not saved
        await ProtectedSessionStorage.DeleteAsync(ChatStorageKey);

    // Reset UI warning state
        isChatHistoryTooLarge = false;
        chatHistorySizeBytes = 0;

        StateHasChanged();
        await ScrollToNewMessage();
    }

    private string FormatFileSize(long bytes)
    {
        if (bytes == 0) return "0 B";
        
        string[] suffixes = { "B", "KB", "MB", "GB" };
        int suffixIndex = 0;
        double size = bytes;

        while (size >= 1024 && suffixIndex < suffixes.Length - 1)
        {
            size /= 1024;
            suffixIndex++;
        }

        return $"{size:F1} {suffixes[suffixIndex]}";
    }

    

    private async Task<(bool exists, string? documentId)> CheckFileExists(string fileName)
    {
        try
        {
            // Load all documents and search for filename
            var response = await ApiService.GetDocumentsAsync(100, 0, null);
            if (response?.Success == true && response.Documents.Count > 0)
            {
                var existingDoc = response.Documents.FirstOrDefault(d => 
                    string.Equals(d.FileName, fileName, StringComparison.OrdinalIgnoreCase));
                
                if (existingDoc != null)
                {
                    return (true, existingDoc.DocumentId);
                }
            }
        }
        catch (Exception)
        {
            // On error assume file doesn't exist
        }

        return (false, null);
    }

    private async Task<bool> PerformFileUpload()
    {
        if (selectedFile == null) return false;

        try
        {
            using var stream = selectedFile.OpenReadStream(maxAllowedSize: MaxUploadSizeBytes);
            
            var response = await ApiService.UploadFileAsync(
                stream, 
                selectedFile.Name, 
                string.IsNullOrWhiteSpace(documentId) ? null : documentId,
                string.IsNullOrWhiteSpace(metadata) ? null : metadata,
                chunkSize,
                chunkOverlap
            );
            
            if (response != null && response.Success)
            {
                messages.Add(new ChatMessage
                {
                    Type = "assistant",
                    Content = $"Datei '{response.FileName}' erfolgreich hochgeladen! Dokument-ID: {response.DocumentId}. Dateigröße: {FormatFileSize(response.FileSizeBytes)}. Es wurden {response.ChunksCreated} Chunks erstellt. Sie können jetzt Fragen zu diesem Inhalt stellen.",
                    Timestamp = DateTime.Now
                });
                await PersistChatAsync();
                return true;
            }
            else
            {
                messages.Add(new ChatMessage
                {
                    Type = "assistant",
                    Content = "Fehler beim Hochladen der Datei. Bitte überprüfen Sie, ob die DriftMind API läuft und erreichbar ist.",
                    Timestamp = DateTime.Now
                });
                await PersistChatAsync();
                return false;
            }
        }
        catch (Exception ex)
        {
            messages.Add(new ChatMessage
            {
                Type = "assistant",
                Content = $"Fehler beim Hochladen der Datei: {ex.Message}",
                Timestamp = DateTime.Now
            });
            await PersistChatAsync();
            return false;
        }
    }

    private async Task OverwriteFile()
    {
        showDuplicateModal = false;
        
        try
        {
            // First delete existing document
            if (!string.IsNullOrEmpty(existingDocumentId))
            {
                await ApiService.DeleteDocumentAsync(existingDocumentId);
            }
            
            // Perform upload
            var uploadSuccess = await PerformFileUpload();
            
            // Reset form only on successful upload
            if (uploadSuccess)
            {
                ResetUploadForm();
                await ScrollToNewMessage();
            }
        }
        finally
        {
            // Reset modal variables
            duplicateFileName = null;
            existingDocumentId = null;
            isUploading = false;
            StateHasChanged();
        }
    }

    private void CancelUpload()
    {
        showDuplicateModal = false;
        duplicateFileName = null;
        existingDocumentId = null;
        isUploading = false;
        StateHasChanged();
    }

    private async Task HandleDownloadError(string error)
    {
        messages.Add(new ChatMessage
        {
            Type = "system",
            Content = $"Download-Fehler: {error}",
            Timestamp = DateTime.Now
        });
        StateHasChanged();
    await PersistChatAsync();
    return;
    }

    private Task HandleDownloadSuccess(string? fileName)
    {
    // Optional: Show success message
        // messages.Add(new ChatMessage
        // {
        //     Type = "system",
    //     Content = $"Download of '{fileName ?? "document"}' started.",
        //     Timestamp = DateTime.Now
        // });
        // StateHasChanged();
        return Task.CompletedTask;
    }

    // Helper method to format time in user's timezone
    private string GetFormattedTime(DateTime timestamp)
    {
        if (TimezoneService.IsInitialized)
        {
            return TimezoneService.FormatUserTime(timestamp, "HH:mm");
        }
        
        // Fallback to UTC if timezone service not initialized
        return timestamp.ToString("HH:mm") + " UTC";
    }

    public class ChatMessage
    {
        public string Id { get; set; } = Guid.NewGuid().ToString("N")[..8]; // Short unique ID
        public string Type { get; set; } = ""; // "user" or "assistant"
        public string Content { get; set; } = "";
        public DateTime Timestamp { get; set; }
        public List<SearchResult>? Results { get; set; }
    }

    public class SearchResult
    {
        public string Content { get; set; } = "";
        public string DocumentId { get; set; } = "";
        public int ChunkIndex { get; set; }
        public double Score { get; set; }
        public string? OriginalFileName { get; set; }
        public bool IsFileAvailable { get; set; }
    }

    // Persistence helpers
    private const string ChatStorageKey = "dmw.chat.messages.v1";
    private const int ChatHistoryMaxBytes = 700 * 1024; // 700KB limit for session storage
    private bool isChatHistoryTooLarge = false;
    private long chatHistorySizeBytes = 0;
    private async Task PersistChatAsync()
    {
        try
        {
            // Do not persist when only the welcome message exists
            if (messages == null || messages.Count <= 1)
            {
                await ProtectedSessionStorage.DeleteAsync(ChatStorageKey);
                isChatHistoryTooLarge = false;
                chatHistorySizeBytes = 0;
                return;
            }

            // Estimate size of JSON payload to persist (UTF-8 bytes)
            var json = System.Text.Json.JsonSerializer.Serialize(messages);
            var sizeBytes = System.Text.Encoding.UTF8.GetByteCount(json);

            if (sizeBytes > ChatHistoryMaxBytes)
            {
                // Do not persist; remove key as a safety measure
                await ProtectedSessionStorage.DeleteAsync(ChatStorageKey);
                isChatHistoryTooLarge = true;
                chatHistorySizeBytes = sizeBytes;
                return;
            }

            // Below limit: persist as usual and reset warning state
            isChatHistoryTooLarge = false;
            chatHistorySizeBytes = sizeBytes;
            await ProtectedSessionStorage.SetAsync(ChatStorageKey, messages);
        }
        catch
        {
            // Ignore persistence errors
        }
    }
}
